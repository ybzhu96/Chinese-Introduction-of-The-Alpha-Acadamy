## [欢迎来到阿尔法学院！](https://www.alphavantage.co/academy/#academy-intro)

Alpha Academy是一个面向全球投资者、软件开发人员、量化研究人员、学生和教育工作者的开放知识库。以下是一个由量化投资、机器学习、软件开发、区块链技术等领域的行业专家开发的不断增加的教育内容列表。

阿尔法学院 | 用心❤️构建，通过[Alpha Vantage: 重新构想的股票市场 API](https://www.alphavantage.co/)



**建立股票投资组合：关键量化因素**

![介绍投资组合建设](https://www.alphavantage.co/static/img/academy-portfolio.jpeg)

图片来自Shutterstock上的艺术家*Jackie Niam*

投资组合构建框架是股票数据分析和交易策略开发的关键，尤其是在高波动、高通胀的经济条件下。在本视频教程中，金融学教授兰迪·科恩 (Randy Cohen) 带领我们了解，建立一个稳健的股票投资组合时需要考虑的主要量化因素：规模、价值、质量、动量和贝塔系数。虽然不同的交易者可能有不同的投资策略和风格，但某些量化因素在投资组合管理实践中往往是通用的。我们希望本教程与我们丰富的股票市场API相结合，能够帮助您打造可靠且可重复地跑赢大盘的股票投资组合。

[进入项目 →](https://www.alphavantage.co/academy/#build-portfolio)

**关键词**：量化投资，交易策略开发，投资组合管理，股票，债券



**金融人工智能简介**

![股票 api 和金融的 ai 介绍](https://www.alphavantage.co/static/img/ai-for-finance-banner.jpeg)

图片来自Shutterstock上的艺术家*Blue Planet Studio*

人工智能 (AI) 和机器学习在股票、ETF、外汇、大宗商品和固定收益等资产类别的金融市场中得到广泛采用。自 2000 年初以来，机器一直在与人类一起交易股票。快进到今天，美国的大部分股票交易活动都是由机器进行的。本视频教程将使您更深入地了解人工智能，以及人工智能系统的两个重要组成部分：机器学习和深度学习。有了这些知识和正确的工具，您将能够利用他们的力量在金融市场上做出明智的决策。

[进入项目 →](https://www.alphavantage.co/academy/#ai-for-finance)

**关键词**：机器学习，深度学习，量化金融，股市API





**用深度神经网络预测股票价格**

![机器学习项目横幅图片](https://www.alphavantage.co/static/img/academy-lstm.jpeg)

图片来自Shutterstock上的艺术家*everything possible*

本项目将引导您，通过使用Alpha Vantage API和名为长短期记忆(LSTM)的强大机器学习算法来开发股票价格运动预测模型的端到端数据科学生命周期。通过完成此项目，您将学习机器学习和深度学习的关键概念，并为股票市场构建一个功能齐全的预测模型，所有的这些都在一个Python文件中完成。

[进入项目 →](https://www.alphavantage.co/academy/#lstm-for-finance)

**关键词**：python，数据科学，机器学习，股票API集成，量化投资





**用Python/Django构建一个股票可视化网站**

![股票数据 API 可视化 Web 应用程序横幅图像](https://www.alphavantage.co/static/img/academy-visualization.jpeg)

图片来自Shutterstock 上的艺术家*PopTika*

数据可视化是许多现代软件应用程序的关键组成部分，尤其是在金融技术 (FinTech) 领域。在这个项目中，我们将使用 Python/Django 和 Alpha Vantage API 创建一个交互式股票可视化网站。我们将在不到 400 行代码中涵盖关键的软件工程和 Web 开发概念，例如 HTML/Javascript/AJAX、服务器端脚本和数据库模型。

[进入项目 →](https://www.alphavantage.co/academy/#django-project-overview)

**关键词**：Web 开发、数据可视化、HTML、Javascript/AJAX、服务器端脚本、SQL、Python/Django



## [股票投资组合构建：关键量化因素](https://www.alphavantage.co/academy/#build-portfolio)

👍 377 | 分享项目链接

客座专家：**Randy Cohen（金融学教授）**

关键词：量化投资，交易策略开发，投资组合管理，股票，债券



在本视频教程中，金融学教授兰迪·科恩 (Randy Cohen) 向我们介绍了在构建稳健的股票投资组合时要考虑的首要量化因素：规模、价值、质量、动量和贝塔系数。虽然不同的交易者可能有不同的投资策略和风格，但某些量化因素在投资组合管理实践中往往是通用的。我们希望本教程与我们丰富的[股票市场 API](https://www.alphavantage.co/)相结合，能够帮助您打造可靠且可重复地跑赢大盘的股票投资组合。



让我们开始吧！

<iframe width="840" height="472" src="https://www.youtube.com/embed/CkRlA8UQrMA" title="YouTube 视频播放器" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" style="box-sizing: border-box;"></iframe>



👍 377 | 分享项目链接



注册我们的[周日早市时事新闻](https://sundaymorningmarkets.substack.com)，了解全球重要的金融和经济新闻！每周日，它都会带着纯粹的市场见解出现在你的电子邮件收件箱里。

在量化投资、机器学习、软件工程和区块链技术领域寻找职业机会？完成此处的项目以解锁[Alpha Academy 证书](https://www.alphatournament.com/certificate_guide/)，并会被介绍给硅谷Y Combinator 网络中的顶级公司！



如果您有兴趣将此项目翻译成英语以外的其他语言，请[告诉我们](mailto:support@alphavantage.co)，我们非常感谢您的帮助！

Wenn Sie daran interessiert sind, dieses Projekt ins Deutsche zu übersetzen, [lassen Sie es uns bitte wissen](mailto:support@alphavantage.co) und wir bedanken uns sehr für Ihre Hilfe!

Si está interesado en traducir este proyecto al español, [háganoslo saber](mailto:support@alphavantage.co) y realmente apreciamos tu ayuda。

Se você está interessado em traduzir este projeto para o português, [por favor nos avise](mailto:support@alphavantage.co) enós realmente apreciamos sua ajuda!

如果您有兴趣把这篇文章翻译成中文，请[联系我们](mailto:support@alphavantage.co)。我们非常感谢您的支持！

本プロジェクト和訳ニご兴味お持ちの方う、是非、[お问い合わせください](mailto:support@alphavantage.co)！ご连络お待ちしえおり！

이프로젝트를한국어로번역하는데관심이있으시면 [저희에게알려주십시오](mailto:support@alphavantage.co)。도움을 주셔서 정말 감사합니다!



*免责声明：阿尔法学院的所有内容仅用于教育目的，并非投资建议。*



## [金融人工智能简介](https://www.alphavantage.co/academy/#ai-for-finance)

👍 390 | 分享项目链接

创建者：**阿尔法学院员工**

关键词：机器学习，深度学习，量化投资，数据科学



人工智能 (AI) 和机器学习正在金融市场中得到广泛应用。自 2000 年初以来，机器一直在与人类一起交易股票。快进到今天，美国的大部分股票交易活动都是由机器进行的。毋庸置疑，许多学术和行业从业者使用[我们的股票 API](https://www.alphavantage.co/)作为他们机器学习算法的主要数据源。这个简短的视频教程将让您更深入地了解人工智能，以及人工智能系统的两个重要组成部分：机器学习和深度学习。有了这些知识和正确的工具，您将能够利用它们的力量来帮助您在金融市场上做出明智的决策。



让我们开始吧！

<iframe width="840" height="472" src="https://www.youtube-nocookie.com/embed/dyZUvP5sAw8" title="YouTube 视频播放器" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" style="box-sizing: border-box;"></iframe>



👍 390 | 分享项目链接



注册我们的[周日早市时事新闻](https://sundaymorningmarkets.substack.com)，了解全球重要的金融和经济新闻！每周日，它都会带着纯粹的市场见解出现在你的电子邮件收件箱里。

在量化投资、机器学习、软件工程和区块链技术领域寻找职业机会？完成此处的项目以解锁[Alpha Academy 证书](https://www.alphatournament.com/certificate_guide/)，并会被介绍给硅谷Y Combinator 网络中的顶级公司！



如果您有兴趣将此项目翻译成英语以外的其他语言，请[告诉我们](mailto:support@alphavantage.co)，我们非常感谢您的帮助！

Wenn Sie daran interessiert sind, dieses Projekt ins Deutsche zu übersetzen, [lassen Sie es uns bitte wissen](mailto:support@alphavantage.co) und wir bedanken uns sehr für Ihre Hilfe!

Si está interesado en traducir este proyecto al español, [háganoslo saber](mailto:support@alphavantage.co) y realmente apreciamos tu ayuda。

Se você está interessado em traduzir este projeto para o português, [por favor nos avise](mailto:support@alphavantage.co) enós realmente apreciamos sua ajuda!

如果您有兴趣把这篇文章翻译成中文，请[联系我们](mailto:support@alphavantage.co)。我们非常感谢您的支持！

本プロジェクト和訳ニご兴味お持ちの方う、是非、[お问い合わせください](mailto:support@alphavantage.co)！ご连络お待ちしえおり！

이프로젝트를한국어로번역하는데관심이있으시면 [저희에게알려주십시오](mailto:support@alphavantage.co)。도움을 주셔서 정말 감사합니다!



*免责声明：阿尔法学院的所有内容仅用于教育目的，并非投资建议。*



## [用深度神经网络预测股票价格](https://www.alphavantage.co/academy/#lstm-for-finance)

👍 425 | 分享项目链接

专家导师：**Jingles (Hong Jing)**（阿里巴巴集团AI研究员；新加坡南洋理工大学）

关键词：python，数据科学，机器学习，深度学习，量化投资，时间序列分析





💡 提示：如果您刚刚开始接触 AI 和机器学习，您可能需要先查看我们的[金融 AI 简介](https://www.alphavantage.co/academy/#ai-for-finance)视频教程，然后再深入这个项目！

深度学习是基于人工神经网络的更广泛的机器学习方法家族的一部分，这些方法的[灵感](https://en.wikipedia.org/wiki/Deep_learning)来自我们大脑自身的神经元网络。在流行的深度学习框架中，[长短期记忆 (LSTM)](https://en.wikipedia.org/wiki/Long_short-term_memory)是一种专门的架构，可以从历史数据序列中“记住”模式，并利用这些模式推断到未来事件。

![img](https://www.alphavantage.co/static/img/lstm_framing.jpeg)
*（插图改编自[维基百科](https://en.wikipedia.org/wiki/Deep_learning#/media/File:AI-ML-DL.svg))*

由于金融市场由股票价格的历史序列组成，越来越多的量化研究人员和金融专业人士正在使用 LTSM 来建模和预测市场价格走势。在这个项目中，我们将经历一个端到端机器学习生命周期，即通过使用Python (PyTorch) 和 Alpha Vantage API 来预测股票市场价格。

该项目分为以下部分，它们代表了典型的[机器学习工作流程](https://cloud.google.com/ai-platform/docs/ml-solutions-overview)：

❚ 安装 Python 依赖项

❚ 数据准备：从 Alpha Vantage 股票 API 获取数据

❚ 数据准备：标准化原始数据

❚ 数据准备：生成训练和验证数据集

❚ 定义 LSTM 模型

❚ 模型训练

❚ 模型评估

❚ 预测未来股票价格

到本项目结束时，您将拥有一个功能齐全的 LSTM 模型，该模型可以根据历史价格走势预测未来的股票价格，所有这些都在一个 Python 文件中。本教程的编写方式已将所有基本代码片段都嵌入到该页面。您应该能够开发、训练和测试您的机器学习模型，而无需参考其他外部页面或文档。

让我们开始吧！



#### [安装 Python 依赖项](https://www.alphavantage.co/academy/#install-python-dependencies)

我们建议为此项目使用**Python 3.6 或更高版本。**如果您的本地环境中没有安装 Python，请访问[python.org](https://www.python.org/downloads/)以获取最新的下载说明。

安装 Python 后，请转到操作系统的命令行界面，使用下面的“pip install”指令分别安装 Numpy、PyTorch、Matplotlib 和 Alpha Vantage：

❚[numpy](https://github.com/numpy/numpy)：`pip install numpy`

❚[PyTorch](https://github.com/pytorch/pytorch)：`pip install torch`

❚ [matplotlib](https://github.com/matplotlib/matplotlib)：`pip install matplotlib`

❚[alpha_vantage](https://github.com/RomelTorres/alpha_vantage)：`pip install alpha_vantage`

现在，创建一个名为`project.py`的新 Python 文件并将以下代码粘贴到该文件中：

```python
import numpy as np


import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
from torch.utils.data import Dataset
from torch.utils.data import DataLoader


import matplotlib.pyplot as plt
from matplotlib.pyplot import figure


from alpha_vantage.timeseries import TimeSeries 


print("All libraries loaded")
```

如果你已经成功安装了上面的所有 Python 依赖项，你应该在运行 project.py 文件后看到文本“All libraries loaded”。

现在将以下代码追加到文件`project.py`中。不要忘记将“YOUR_API_KEY”替换为您的实际 Alpha Vantage API 密钥，该密钥可以从[Alpha Vantage 支持页面](https://www.alphavantage.co/support/)获得。

```python
config = {
    "alpha_vantage": {
        "key": "demo", # you can use the demo API key for this project, but please make sure to get your own API key at https://www.alphavantage.co/support/#api-key
        "symbol": "IBM",
        "outputsize": "full",
        "key_adjusted_close": "5. adjusted close",
    },
    "data": {
        "window_size": 20,
        "train_split_size": 0.80,
    }, 
    "plots": {
        "xticks_interval": 90, # show a date every 90 days
        "color_actual": "#001f3f",
        "color_train": "#3D9970",
        "color_val": "#0074D9",
        "color_pred_train": "#3D9970",
        "color_pred_val": "#0074D9",
        "color_pred_test": "#FF4136",
    },
    "model": {
        "input_size": 1, # since we are only using 1 feature, close price
        "num_lstm_layers": 2,
        "lstm_size": 32,
        "dropout": 0.2,
    },
    "training": {
        "device": "cpu", # "cuda" or "cpu"
        "batch_size": 64,
        "num_epoch": 100,
        "learning_rate": 0.01,
        "scheduler_step_size": 40,
    }
}
```

在这个项目的过程中，我们将继续向`project.py`文件中添加新的代码块。到本教程结束时，您应该拥有一个功能齐全的 LSTM 机器学习模型来预测股票市场价格走势，所有这些都在一个 Python 脚本中完成。如果您想在项目期间进行“健全性检查”，请随时将您的`project.py`文件代码与[源代码](https://github.com/jinglescode/time-series-forecasting-pytorch/blob/main/project.py)进行比较。



#### [数据准备：从 Alpha Vantage 股票 API 获取数据](https://www.alphavantage.co/academy/#data-prep-alpha-vantage)

在这个项目中，我们将训练一个 LSTM 模型来预测股价走势。在我们构建预测未来的“水晶球”之前，我们需要历史股价数据来训练我们的深度学习模型。为此，我们将通过[流行的 Python 包装器](https://github.com/RomelTorres/alpha_vantage)查询[Alpha Vantage 股票 API](https://www.alphavantage.co/)。对于本项目，我们将获得 IBM 从 1999 年 11 月到 2021 年 4 月 29 日超过 20 年的每日收盘价。

![Alpha Vantage 股票数据 API 的原始输出](https://github.com/AlphaVantageSupport/time-series-forecasting-pytorch/raw/main/static/figure01-history-price.png)



将以下代码块追加到您的`project.py`文件。如果您现在重新运行该文件，借助强大的`matplotlib`库，它应该会生成类似于上面的图表。

```python
def download_data(config):
    ts = TimeSeries(key='demo') #you can use the demo API key for this project, but please make sure to eventually get your own API key at https://www.alphavantage.co/support/#api-key. 
    data, meta_data = ts.get_daily_adjusted(config["alpha_vantage"]["symbol"], outputsize=config["alpha_vantage"]["outputsize"])


    data_date = [date for date in data.keys()]
    data_date.reverse()


    data_close_price = [float(data[date][config["alpha_vantage"]["key_adjusted_close"]]) for date in data.keys()]
    data_close_price.reverse()
    data_close_price = np.array(data_close_price)


    num_data_points = len(data_date)
    display_date_range = "from " + data_date[0] + " to " + data_date[num_data_points-1]
    print("Number data points", num_data_points, display_date_range)


    return data_date, data_close_price, num_data_points, display_date_range


data_date, data_close_price, num_data_points, display_date_range = download_data(config)


# plot


fig = figure(figsize=(25, 5), dpi=80)
fig.patch.set_facecolor((1.0, 1.0, 1.0))
plt.plot(data_date, data_close_price, color=config["plots"]["color_actual"])
xticks = [data_date[i] if ((i%config["plots"]["xticks_interval"]==0 and (num_data_points-i) > config["plots"]["xticks_interval"]) or i==num_data_points-1) else None for i in range(num_data_points)] # make x ticks nice
x = np.arange(0,len(xticks))
plt.xticks(x, xticks, rotation='vertical')
plt.title("Daily close price for " + config["alpha_vantage"]["symbol"] + ", " + display_date_range)
plt.grid(b=None, which='major', axis='y', linestyle='--')
plt.show()
```

请注意，我们正在使用Alpha Vantage 的[daily adjusted API](https://www.alphavantage.co/documentation/#dailyadj)的调整收盘，来消除由于股票拆分和股息支付事件引起的任何人为价格波动。通常认为使用拆分/股息调整后的价格而不是原始收盘价，是用来模拟股票价格变动的[行业最佳实践](http://www.crsp.org/products/documentation/crsp-calculations)。



#### [数据准备：标准化原始金融数据](https://www.alphavantage.co/academy/#data-normalization)

使用[梯度下降](https://en.wikipedia.org/wiki/Gradient_descent)作为优化技术的机器学习算法（例如我们的 LSTM 算法）需要对数据进行缩放。这是因为模型中的特征值会影响梯度下降的步长，可能会以意想不到的方式扭曲 LSTM 模型。

这就是**数据标准化**的用武之地。标准化可以提高模型的准确性并帮助梯度下降算法更快地收敛。通过将输入数据置于同一尺度并降低其方差，人工神经网络中的所有权重都不会浪费在标准化任务上，这意味着 LSTM 模型可以更有效地从数据中学习并将模式存储在网络中。此外，LSTM 本质上对输入数据的规模很敏感。由于上述原因，对数据进行标准化至关重要。

由于股票价格可以从几十到几百和几千不等（就 IBM 而言，每股价格为 40 美元到 160 美元），因此在将数据输入LSTM模型之前，我们将对股票价格进行标准化，标准化这些值的范围。下面的代码片段将数据重新缩放，使其均值为0，标准差为1。

将以下数据标准化代码块追加到您的`project.py`文件。

```python
class Normalizer():
    def __init__(self):
        self.mu = None
        self.sd = None


    def fit_transform(self, x):
        self.mu = np.mean(x, axis=(0), keepdims=True)
        self.sd = np.std(x, axis=(0), keepdims=True)
        normalized_x = (x - self.mu)/self.sd
        return normalized_x


    def inverse_transform(self, x):
        return (x*self.sd) + self.mu


# normalize
scaler = Normalizer()
normalized_data_close_price = scaler.fit_transform(data_close_price)
```



#### [数据准备：生成训练和验证数据集](https://www.alphavantage.co/academy/#split-data-set)

LSTM 等[有监督机器学习方法](https://en.wikipedia.org/wiki/Supervised_learning)学习从输入变量 (X) 到输出变量 (Y) 的映射函数。从训练数据集中学习可以被认为是一个老师监督学习过程，老师知道所有的正确答案。

在这个项目中，我们将训练模型根据过去 20 天的收盘价预测第 21 天的收盘价。选择天数 20 是基于以下几个原因：

❚ 当 LSTM 模型用于自然语言处理时，一个句子中的单词数通常在 15 到 20 个单词之间

❚ 梯度下降注意事项：尝试在非常长的输入序列中反向传播可能会导致梯度消失（稍后会详细介绍）

❚ 较长的序列往往需要更长的训练时间

将数据集转换为输入特征和输出标签后，我们X的形状为`(5388, 20)`，其中5388是行数，每行包含过去 20 天的价格序列。对应的 Y 数据形状为`(5388,)`，与 X 中的行数匹配。

我们还将数据集分成两部分，用于训练和验证。我们将数据分成 80:20。80% 的数据用于训练，其余 20% 用于验证我们的模型在预测未来价格方面的表现。（或者，另一种常见的做法是将初始数据以 70/20/10 的分配比例分为训练集、验证集和测试集，其中在训练过程中完全不使用测试数据集。）下图显示了部分用于训练和验证的数据——大致来说，2017 年之前的数据用于训练，2017 年之后的数据用于模型结果验证。

![数据拆分](https://github.com/AlphaVantageSupport/time-series-forecasting-pytorch/raw/main/static/figure02-train-validation-split.png)



将以下代码块追加到您的`project.py`文件。如果您现在重新运行该文件，它应该会生成一个类似于上面的图表，其中训练数据为绿色，验证数据为蓝色。

```python
def prepare_data_x(x, window_size):
    # perform windowing
    n_row = x.shape[0] - window_size + 1
    output = np.lib.stride_tricks.as_strided(x, shape=(n_row, window_size), strides=(x.strides[0], x.strides[0]))
    return output[:-1], output[-1]




def prepare_data_y(x, window_size):
    # # perform simple moving average
    # output = np.convolve(x, np.ones(window_size), 'valid') / window_size


    # use the next day as label
    output = x[window_size:]
    return output


data_x, data_x_unseen = prepare_data_x(normalized_data_close_price, window_size=config["data"]["window_size"])
data_y = prepare_data_y(normalized_data_close_price, window_size=config["data"]["window_size"])


# split dataset


split_index = int(data_y.shape[0]*config["data"]["train_split_size"])
data_x_train = data_x[:split_index]
data_x_val = data_x[split_index:]
data_y_train = data_y[:split_index]
data_y_val = data_y[split_index:]


# prepare data for plotting


to_plot_data_y_train = np.zeros(num_data_points)
to_plot_data_y_val = np.zeros(num_data_points)


to_plot_data_y_train[config["data"]["window_size"]:split_index+config["data"]["window_size"]] = scaler.inverse_transform(data_y_train)
to_plot_data_y_val[split_index+config["data"]["window_size"]:] = scaler.inverse_transform(data_y_val)


to_plot_data_y_train = np.where(to_plot_data_y_train == 0, None, to_plot_data_y_train)
to_plot_data_y_val = np.where(to_plot_data_y_val == 0, None, to_plot_data_y_val)


## plots


fig = figure(figsize=(25, 5), dpi=80)
fig.patch.set_facecolor((1.0, 1.0, 1.0))
plt.plot(data_date, to_plot_data_y_train, label="Prices (train)", color=config["plots"]["color_train"])
plt.plot(data_date, to_plot_data_y_val, label="Prices (validation)", color=config["plots"]["color_val"])
xticks = [data_date[i] if ((i%config["plots"]["xticks_interval"]==0 and (num_data_points-i) > config["plots"]["xticks_interval"]) or i==num_data_points-1) else None for i in range(num_data_points)] # make x ticks nice
x = np.arange(0,len(xticks))
plt.xticks(x, xticks, rotation='vertical')
plt.title("Daily close prices for " + config["alpha_vantage"]["symbol"] + " - showing training and validation data")
plt.grid(b=None, which='major', axis='y', linestyle='--')
plt.legend()
plt.show()
```

我们将使用[PyTorch](https://pytorch.org/)框架来训练我们的模型，Pytorch框架是一个用 Python 编写的机器学习库。PyTorch 数据加载程序的核心是 [DataLoader](https://pytorch.org/docs/stable/data.html)类，这是一种高效的数据生成方案，可在训练过程中充分利用计算机图形处理单元(GPU)的潜力。`DataLoader`需要[Dataset](https://pytorch.org/docs/stable/data.html#torch.utils.data.Dataset)对象来定义加载的数据。`Dataset`是map型数据集，它实现了`__getitem__()`和`__len__()`协议，表示从索引到数据样本的映射。

将以下代码块追加到您的`project.py`文件以实现数据加载器功能。

```python
class TimeSeriesDataset(Dataset):
    def __init__(self, x, y):
        x = np.expand_dims(x, 2) # in our case, we have only 1 feature, so we need to convert `x` into [batch, sequence, features] for LSTM
        self.x = x.astype(np.float32)
        self.y = y.astype(np.float32)
        
    def __len__(self):
        return len(self.x)


    def __getitem__(self, idx):
        return (self.x[idx], self.y[idx])


dataset_train = TimeSeriesDataset(data_x_train, data_y_train)
dataset_val = TimeSeriesDataset(data_x_val, data_y_val)


print("Train data shape", dataset_train.x.shape, dataset_train.y.shape)
print("Validation data shape", dataset_val.x.shape, dataset_val.y.shape)


train_dataloader = DataLoader(dataset_train, batch_size=config["training"]["batch_size"], shuffle=True)
val_dataloader = DataLoader(dataset_val, batch_size=config["training"]["batch_size"], shuffle=True)
```



#### [定义 LSTM 模型](https://www.alphavantage.co/academy/#define-model)

现在训练和评估数据已完全标准化并准备就绪，我们准备构建我们的LSTM模型了！

如前所述，LSTM 是一种专门的人工神经网络架构，可以从历史数据序列中“记住”模式，并基于这些模式对未来事件进行推断。具体来说，它属于一组称为[循环神经网络 (RNN)](https://en.wikipedia.org/wiki/Recurrent_neural_network)的人工神经网络。

LSTM 是一种流行的人工神经网络，因为它设法克服了 RNN 的许多技术限制。例如，当数据序列大于 5 到 10 时，由于[梯度消失问题](https://en.wikipedia.org/wiki/Vanishing_gradient_problem)，RNN 无法学习，此时梯度逐渐变小，有效地阻止了模型的学习。LSTM 可以通过自连接的隐藏层(包含记忆单元和相应的门单元)强制执行恒定的错误流来学习长序列的数据。如果你有兴趣了解更多关于 LSTM 和 RNN 的内部工作原理，[这里](https://colah.github.io/posts/2015-08-Understanding-LSTMs/)是一个很好的供你参考的解释。

我们的人工神经网络主要有三层，每一层都有特定的逻辑目的:

❚ 线性层 1 ( `linear_1`)：将输入值映射到高维特征空间，将特征转换为 LSTM 层

❚ LSTM ( `lstm`)：按顺序学习数据

❚ 线性层 2 ( `linear_2`)：根据 LSTM 的输出产生预测值

我们还添加了[Dropout](https://pytorch.org/docs/stable/generated/torch.nn.Dropout.html)，在训练过程中随机选择人工神经元进行忽略，从而使网络正则化以防止过拟合，并提高整体模型表现。作为一个可选步骤，我们还初始化了 LSTM 的模型权重，正如一些研究人员观察到的那样，它可以帮助模型更有效地学习。

将以下代码块追加到您的`project.py`文件以指定 LSTM 模型。

```python
class LSTMModel(nn.Module):
    def __init__(self, input_size=1, hidden_layer_size=32, num_layers=2, output_size=1, dropout=0.2):
        super().__init__()
        self.hidden_layer_size = hidden_layer_size


        self.linear_1 = nn.Linear(input_size, hidden_layer_size)
        self.relu = nn.ReLU()
        self.lstm = nn.LSTM(hidden_layer_size, hidden_size=self.hidden_layer_size, num_layers=num_layers, batch_first=True)
        self.dropout = nn.Dropout(dropout)
        self.linear_2 = nn.Linear(num_layers*hidden_layer_size, output_size)
        
        self.init_weights()


    def init_weights(self):
        for name, param in self.lstm.named_parameters():
            if 'bias' in name:
                 nn.init.constant_(param, 0.0)
            elif 'weight_ih' in name:
                 nn.init.kaiming_normal_(param)
            elif 'weight_hh' in name:
                 nn.init.orthogonal_(param)


    def forward(self, x):
        batchsize = x.shape[0]


        # layer 1
        x = self.linear_1(x)
        x = self.relu(x)
        
        # LSTM layer
        lstm_out, (h_n, c_n) = self.lstm(x)


        # reshape output from hidden cell into [batch, features] for `linear_2`
        x = h_n.permute(1, 0, 2).reshape(batchsize, -1) 
        
        # layer 2
        x = self.dropout(x)
        predictions = self.linear_2(x)
        return predictions[:,-1]
```



#### [模型训练](https://www.alphavantage.co/academy/#model-training)

LSTM模型通过对训练数据X进行迭代预测来进行学习。我们使用[均方误差](https://en.wikipedia.org/wiki/Mean_squared_error)作为代价函数，它衡量预测值与实际值之间的差异。当模型做出不好的预测时，代价函数返回的误差值会比较高。模型将通过[反向传播](https://en.wikipedia.org/wiki/Backpropagation)微调其权重，提高其做出更好预测的能力。当算法达到可接受的表现水平时，学习停止，此时验证数据集上代价函数返回的错误值不再增加。

我们使用[Adam 优化器](https://pytorch.org/docs/master/generated/torch.optim.Adam.html)，它通过`step()`方法根据学习率更新模型的参数。这就是模型学习和微调预测的方式。学习率控制模型收敛的速度。学习率过高会导致模型过快地收敛到次优解，而较小的学习率需要更多的训练迭代，并可能导致模型寻找最优解的时间延长。我们还使用[StepLR 调度器](https://pytorch.org/docs/master/generated/torch.optim.lr_scheduler.StepLR.html)来降低训练过程中的学习率。您也可以尝试[ReduceLROnPlateau](https://pytorch.org/docs/master/generated/torch.optim.lr_scheduler.ReduceLROnPlateau.html)调度器，当代价函数在“耐心”数量的epoch内停止改进时，它会降低学习率。为您的项目选择合适的学习率既是一门艺术，也是一门科学，并且是机器学习社区中一个深入研究的话题。

将以下代码块追加到您的`project.py`文件并重新运行该文件以启动模型训练过程。

```python
def run_epoch(dataloader, is_training=False):
    epoch_loss = 0


    if is_training:
        model.train()
    else:
        model.eval()


    for idx, (x, y) in enumerate(dataloader):
        if is_training:
            optimizer.zero_grad()


        batchsize = x.shape[0]


        x = x.to(config["training"]["device"])
        y = y.to(config["training"]["device"])


        out = model(x)
        loss = criterion(out.contiguous(), y.contiguous())


        if is_training:
            loss.backward()
            optimizer.step()


        epoch_loss += (loss.detach().item() / batchsize)


    lr = scheduler.get_last_lr()[0]


    return epoch_loss, lr


train_dataloader = DataLoader(dataset_train, batch_size=config["training"]["batch_size"], shuffle=True)
val_dataloader = DataLoader(dataset_val, batch_size=config["training"]["batch_size"], shuffle=True)


model = LSTMModel(input_size=config["model"]["input_size"], hidden_layer_size=config["model"]["lstm_size"], num_layers=config["model"]["num_lstm_layers"], output_size=1, dropout=config["model"]["dropout"])
model = model.to(config["training"]["device"])


criterion = nn.MSELoss()
optimizer = optim.Adam(model.parameters(), lr=config["training"]["learning_rate"], betas=(0.9, 0.98), eps=1e-9)
scheduler = optim.lr_scheduler.StepLR(optimizer, step_size=config["training"]["scheduler_step_size"], gamma=0.1)


for epoch in range(config["training"]["num_epoch"]):
    loss_train, lr_train = run_epoch(train_dataloader, is_training=True)
    loss_val, lr_val = run_epoch(val_dataloader)
    scheduler.step()
    
    print('Epoch[{}/{}] | loss train:{:.6f}, test:{:.6f} | lr:{:.6f}'
              .format(epoch+1, config["training"]["num_epoch"], loss_train, loss_val, lr_train))
```

运行脚本后，您将在控制台中看到类似以下内容的输出：

```
Epoch[1/100] | loss train:0.063952, test:0.001398 | lr:0.010000Epoch[2/100] | loss train:0.011749, test:0.002024 | lr:0.010000Epoch[3/100] | loss train:0.009831, test:0.001156 | lr:0.010000Epoch[4/100] | loss train:0.008264, test:0.001022 | lr:0.010000...Epoch[97/100] | loss train:0.006143, test:0.000972 | lr:0.000100Epoch[98/100] | loss train:0.006267, test:0.000974 | lr:0.000100Epoch[99/100] | loss train:0.006168, test:0.000985 | lr:0.000100Epoch[100/100] | loss train:0.006102, test:0.000972 | lr:0.000100
```

使用均方误差作为损失函数来优化我们的模型，上面的日志输出是根据模型的学习情况逐步计算出的“损失”值。在每个 epoch 之后，较小的损失值表示模型学习良好，0.0 表示没有出错。`Loss train`给出了模型学习好坏的情况，而`loss test`显示了模型对验证数据集的泛化效果。一个训练良好的模型是通过训练和验证损失来识别的，该损失减少到两个最终损失值之间可以忽略不计的差异（在这个阶段，我们说模型已经“收敛”）。通常，模型在训练数据集上的损失值会低于在验证数据集上的损失值。



#### [模型评估](https://www.alphavantage.co/academy/#model-evaluation)

为了直观地检查我们模型的表现，我们将使用新训练的模型，对我们在这个项目早期创建的训练和验证数据集进行预测。如果我们看到该模型可以预测与训练数据集非常相似的值，则表明该模型成功地记住了数据。如果模型可以预测与验证数据集相似的值，那么它已经成功地学习了序列数据中的模式，并将模式推广到未见过的数据点。

![训练结果](https://github.com/AlphaVantageSupport/time-series-forecasting-pytorch/raw/main/static/figure03-actual-vs-predicted.png)



将以下代码块追加到`project.py`文件。重新运行该文件应该会生成类似于上图的图表。

```python
# here we re-initialize dataloader so the data doesn't shuffled, so we can plot the values by date


train_dataloader = DataLoader(dataset_train, batch_size=config["training"]["batch_size"], shuffle=False)
val_dataloader = DataLoader(dataset_val, batch_size=config["training"]["batch_size"], shuffle=False)


model.eval()


# predict on the training data, to see how well the model managed to learn and memorize


predicted_train = np.array([])


for idx, (x, y) in enumerate(train_dataloader):
    x = x.to(config["training"]["device"])
    out = model(x)
    out = out.cpu().detach().numpy()
    predicted_train = np.concatenate((predicted_train, out))


# predict on the validation data, to see how the model does


predicted_val = np.array([])


for idx, (x, y) in enumerate(val_dataloader):
    x = x.to(config["training"]["device"])
    out = model(x)
    out = out.cpu().detach().numpy()
    predicted_val = np.concatenate((predicted_val, out))


# prepare data for plotting


to_plot_data_y_train_pred = np.zeros(num_data_points)
to_plot_data_y_val_pred = np.zeros(num_data_points)


to_plot_data_y_train_pred[config["data"]["window_size"]:split_index+config["data"]["window_size"]] = scaler.inverse_transform(predicted_train)
to_plot_data_y_val_pred[split_index+config["data"]["window_size"]:] = scaler.inverse_transform(predicted_val)


to_plot_data_y_train_pred = np.where(to_plot_data_y_train_pred == 0, None, to_plot_data_y_train_pred)
to_plot_data_y_val_pred = np.where(to_plot_data_y_val_pred == 0, None, to_plot_data_y_val_pred)


# plots


fig = figure(figsize=(25, 5), dpi=80)
fig.patch.set_facecolor((1.0, 1.0, 1.0))
plt.plot(data_date, data_close_price, label="Actual prices", color=config["plots"]["color_actual"])
plt.plot(data_date, to_plot_data_y_train_pred, label="Predicted prices (train)", color=config["plots"]["color_pred_train"])
plt.plot(data_date, to_plot_data_y_val_pred, label="Predicted prices (validation)", color=config["plots"]["color_pred_val"])
plt.title("Compare predicted prices to actual prices")
xticks = [data_date[i] if ((i%config["plots"]["xticks_interval"]==0 and (num_data_points-i) > config["plots"]["xticks_interval"]) or i==num_data_points-1) else None for i in range(num_data_points)] # make x ticks nice
x = np.arange(0,len(xticks))
plt.xticks(x, xticks, rotation='vertical')
plt.grid(b=None, which='major', axis='y', linestyle='--')
plt.legend()
plt.show()
```

从我们的结果中，我们可以看到模型已经成功地学习和预测了训练（绿色）和验证（蓝色）数据集，因为“预测价格”线与“实际价格”值明显重叠。

让我们放大图表，仔细观察蓝色的“预测价格(验证)”部分，并将其与实际价格值进行比较。

![训练结果放大](https://github.com/AlphaVantageSupport/time-series-forecasting-pytorch/raw/main/static/figure04-actual-vs-predicted-zoom.png)



将以下代码块追加到您的`project.py`文件，并重新运行脚本以生成放大后的图形。

```python
# prepare data for plotting the zoomed in view of the predicted prices (on validation set) vs. actual prices


to_plot_data_y_val_subset = scaler.inverse_transform(data_y_val)
to_plot_predicted_val = scaler.inverse_transform(predicted_val)
to_plot_data_date = data_date[split_index+config["data"]["window_size"]:]


# plots


fig = figure(figsize=(25, 5), dpi=80)
fig.patch.set_facecolor((1.0, 1.0, 1.0))
plt.plot(to_plot_data_date, to_plot_data_y_val_subset, label="Actual prices", color=config["plots"]["color_actual"])
plt.plot(to_plot_data_date, to_plot_predicted_val, label="Predicted prices (validation)", color=config["plots"]["color_pred_val"])
plt.title("Zoom in to examine predicted price on validation data portion")
xticks = [to_plot_data_date[i] if ((i%int(config["plots"]["xticks_interval"]/5)==0 and (len(to_plot_data_date)-i) > config["plots"]["xticks_interval"]/6) or i==len(to_plot_data_date)-1) else None for i in range(len(to_plot_data_date))] # make x ticks nice
xs = np.arange(0,len(xticks))
plt.xticks(xs, xticks, rotation='vertical')
plt.grid(b=None, which='major', axis='y', linestyle='--')
plt.legend()
plt.show()
```

多么美丽的图表！您可以看到预测价格（蓝色）与 IBM 的实际价格（黑色）明显重叠。

还值得注意的是，模型训练和评估是一个迭代过程。请随时返回[模型训练](https://www.alphavantage.co/academy/#model-training)步骤微调模型并重新评估模型，看看是否有进一步的效果提升。



#### [预测未来股票价格](https://www.alphavantage.co/academy/#predict-future-price)

到目前为止，我们已经训练了一个 LSTM 模型，它可以（相当准确地）根据过去 20 天的收盘价预测第二天的价格。这意味着我们现在有一颗水晶球！让我们向模型提供过去 20 天的收盘价，看看它对下一个交易日（即未来！）的预测。将以下代码追加到您的`project.py`文件并最后一次重新运行脚本。

```python
# predict the closing price of the next trading day


model.eval()


x = torch.tensor(data_x_unseen).float().to(config["training"]["device"]).unsqueeze(0).unsqueeze(2) # this is the data type and shape required, [batch, sequence, feature]
prediction = model(x)
prediction = prediction.cpu().detach().numpy()


# prepare plots


plot_range = 10
to_plot_data_y_val = np.zeros(plot_range)
to_plot_data_y_val_pred = np.zeros(plot_range)
to_plot_data_y_test_pred = np.zeros(plot_range)


to_plot_data_y_val[:plot_range-1] = scaler.inverse_transform(data_y_val)[-plot_range+1:]
to_plot_data_y_val_pred[:plot_range-1] = scaler.inverse_transform(predicted_val)[-plot_range+1:]


to_plot_data_y_test_pred[plot_range-1] = scaler.inverse_transform(prediction)


to_plot_data_y_val = np.where(to_plot_data_y_val == 0, None, to_plot_data_y_val)
to_plot_data_y_val_pred = np.where(to_plot_data_y_val_pred == 0, None, to_plot_data_y_val_pred)
to_plot_data_y_test_pred = np.where(to_plot_data_y_test_pred == 0, None, to_plot_data_y_test_pred)


# plot


plot_date_test = data_date[-plot_range+1:]
plot_date_test.append("tomorrow")


fig = figure(figsize=(25, 5), dpi=80)
fig.patch.set_facecolor((1.0, 1.0, 1.0))
plt.plot(plot_date_test, to_plot_data_y_val, label="Actual prices", marker=".", markersize=10, color=config["plots"]["color_actual"])
plt.plot(plot_date_test, to_plot_data_y_val_pred, label="Past predicted prices", marker=".", markersize=10, color=config["plots"]["color_pred_val"])
plt.plot(plot_date_test, to_plot_data_y_test_pred, label="Predicted price for next day", marker=".", markersize=20, color=config["plots"]["color_pred_test"])
plt.title("Predicted close price of the next trading day")
plt.grid(b=None, which='major', axis='y', linestyle='--')
plt.legend()
plt.show()


print("Predicted close price of the next trading day:", round(to_plot_data_y_test_pred[plot_range-1], 2))
```

运行脚本将生成类似于下图的预测图：

![价格预测图](https://github.com/AlphaVantageSupport/time-series-forecasting-pytorch/raw/main/static/figure05-predict-the-unseen.png)



图中的红点是我们的模型预测的IBM在下一个交易日的收盘价。

预测是否足够好？TSLA、APPL 或 Reddit 最受欢迎的 Gamestop (GME) 等其他股票怎么样？其他资产类别如[外汇](https://www.alphavantage.co/documentation/#fx)或[加密货币](https://www.alphavantage.co/documentation/#digital-currency)呢？除了收盘价之外，是否还有任何其他外部数据可以提供给 LSTM 模型，以使其更加鲁鲁棒——例如，来自 Alpha Vantage API 的[50 多个技术指标](https://www.alphavantage.co/documentation/#technical-indicators)之一？

现在您已经了解了金融市场数据的机器学习的基础知识，未来充满无限可能。我们特此将接力棒传递给您——我们无所畏惧的读者！



👍 425 | 分享项目链接



#### [参考](https://www.alphavantage.co/academy/#lstm-project-references)

完整`project.py`源代码：[链接](https://github.com/jinglescode/time-series-forecasting-pytorch/blob/main/project.py)

通过 GitHub Issues 提交您的问题或评论：[链接](https://github.com/jinglescode/time-series-forecasting-pytorch/issues)

在Google Colab Jupyter notebook中利用GPU运行脚本：[链接](https://colab.research.google.com/github/jinglescode/time-series-forecasting-pytorch/blob/main/demo-predicting-stock-prices.ipynb)

在本地 Jupyter Notebook 上运行脚本：

```
git clone https://github.com/jinglescode/time-series-forecasting-pytorch.git`
`pip install -r requirements.txt
```



注册我们的[周日早市时事新闻](https://sundaymorningmarkets.substack.com/，了解全球重要的金融和经济新闻！每周日，它都会带着纯粹的市场见解出现在你的电子邮件收件箱里。

在量化投资、机器学习、软件工程和区块链技术领域寻找职业机会？完成此处的项目以解锁[Alpha Academy 证书](https://www.alphatournament.com/certificate_guide/)，并会被介绍给硅谷Y Combinator 网络中的顶级公司！



如果您有兴趣将此项目翻译成英语以外的其他语言，请[告诉我们](mailto:support@alphavantage.co)，我们非常感谢您的帮助！

Wenn Sie daran interessiert sind, dieses Projekt ins Deutsche zu übersetzen, [lassen Sie es uns bitte wissen](mailto:support@alphavantage.co) und wir bedanken uns sehr für Ihre Hilfe!

Si está interesado en traducir este proyecto al español, [háganoslo saber](mailto:support@alphavantage.co) y realmente apreciamos tu ayuda。

Se você está interessado em traduzir este projeto para o português, [por favor nos avise](mailto:support@alphavantage.co) enós realmente apreciamos sua ajuda!

如果您有兴趣把这篇文章翻译成中文，请[联系我们](mailto:support@alphavantage.co)。我们非常感谢您的支持！

本プロジェクト和訳ニご兴味お持ちの方う、是非、[お问い合わせください](mailto:support@alphavantage.co)！ご连络お待ちしえおり！

이프로젝트를한국어로번역하는데관심이있으시면 [저희에게알려주십시오](mailto:support@alphavantage.co)。도움을 주셔서 정말 감사합니다!



*免责声明：阿尔法学院的所有内容仅用于教育目的，并非投资建议。*

## [用Python/Django构建一个股票可视化网站](https://www.alphavantage.co/academy/#django-project-overview)

👍 277 | 分享项目链接

专家导师：**Daniel Petrow** (Alpha Vantage)

关键词：Web 开发、数据可视化、HTML、Javascript/AJAX、服务器端脚本、SQL、Python/Django





数据可视化是越来越多的 Web、移动和物联网应用程序的必备功能。这种趋势在金融市场数据领域更为突出，数据可视化通常用于市场情报、技术图表和其他关键业务和/或定量场景，例如探索性数据分析 (EDA)。

在这个项目中，我们将使用 Python/Django 和 Alpha Vantage API 创建一个交互式股票可视化网站（截图如下）。我们将在不到 400 行的代码中涵盖关键的软件工程和 Web 开发概念，例如 AJAX、服务器端脚本和数据库模型。

![股票可视化主页模型](https://github.com/AlphaVantageSupport/stock_visualization_in_python_django/blob/main/homepage_layout.png?raw=true)



该项目由以下各部分组成：

❚ 安装依赖项并设置项目

❚ 创建数据库模型

❚ 创建前端 UI

❚ 创建后端逻辑

❚ 设置 Django URL 路由

❚ 在本地运行Web应用程序

为了最大限度地减少您的认知负担，我们在本文档中直接包含了所有必要的代码脚本和命令行指令。完成本教程后，您将拥有一个前端、后端和数据库都已准备就绪的股票数据可视化网站。让我们开始吧！



#### [安装依赖项并设置项目](https://www.alphavantage.co/academy/#install-dependencies-django)

我们推荐**Python 3.6 或更高版本**。如果您还没有安装 Python，请按照[python.org](https://www.python.org/)官方网站上的下载说明进行操作。

在环境中安装 Python 后，请使用命令行界面安装以下 Python 库：

❚[Django](https://www.djangoproject.com/download/)：`pip install django`

❚[requests](https://pypi.org/project/requests/)：`pip install requests`

如果您使用的是从 python.org 下载的 Python 3.6 或更高版本，则上面的安装程序`pip`应该已经包含在您的系统中。如果您看到“pip not found”的错误消息，请参阅[pip 安装指南](https://pip.pypa.io/en/stable/installing/)。

也请在[此处](https://www.alphavantage.co/support/#api-key)获取免费的 Alpha Vantage API 密钥。在开发此股票可视化 Web 应用程序时，您将使用此 API 密钥从我们的[REST 股票 API](https://www.alphavantage.co/)中查询股票市场数据。



现在，我们开始去创建 Django 项目了！

打开一个新的命令行窗口并输入以下指令：

```
(home) $ django-admin startproject alphaVantage
```

您刚刚在名为`alphaVantage`的文件夹中创建了一个空白的 Django 项目。

现在，让我们使用以下命令行指令从您的主目录切换到`alphaVantage`项目目录：

```
(home) $ cd alphaVantage
```

对于这个项目的其余部分，我们将在`alphaVantage`根目录中操作。



现在，让我们在空白的 Django 项目中创建一个`stockVisualizer`应用程序：

```
(alphaVantage) $ python manage.py startapp stockVisualizer
```

我们还将为我们的主页创建一个 HTML 文件。依次输入以下4个命令行指令：

第 1 步：创建一个名为“templates”的新文件夹

```
(alphaVantage) $ mkdir templates
```

第 2 步：进入“模板”文件夹

```
(alphaVantage) $ cd templates
```

第 3 步：在`templates`文件夹内创建一个空的`home.html`文件

如果您使用的是 Mac 或 Linux：
`(templates) $ touch home.html`

如果您使用的是 Windows：
`(templates) $ type nul > home.html`

第 4 步：回到我们的`alphaVantage`根目录

```
(templates) $ cd ../
```



在此阶段，您的 Django 项目的文件结构应类似于下面的结构。您可能希望将项目导入 PyCharm、Visual Studio 或 Sublime Text 等 IDE，以便更轻松地可视化文件结构。

```
alphaVantage/
    alphaVantage/
        __init__.py
        asgi.py
        settings.py
        urls.py
        wsgi.py
    stockVisualizer/
        migrations/
            __init__.py
        __init__.py
        admin.py
        apps.py
        models.py
        tests.py
        views.py
    templates/
        home.html
    manage.py
```



让我们仔细看看一些关键文件：

❚ `manage.py`：一个命令行实用程序，允许您以各种方式与这个Django项目交互。您可以在[django-admin 和 manage.py](https://docs.djangoproject.com/en/3.2/ref/django-admin/)中，阅读有关 manage.py 的所有详细信息。

❚ `__init__.py`：一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包。请保持内容为空！

❚ `settings.py`：此 Django 项目的设置/配置。

❚ `urls.py`: 这个 Django 项目的 URL 声明；您的 Django 网站的“目录”。

❚ `models.py`：这是您将用于定义数据库对象和模式的文件。

❚ `views.py`：这是所有后端逻辑实现并传递到前端(视图)的文件。

❚ `home.html`：决定主页外观和行为的 HTML 文件。



#### [指定数据库模型](https://www.alphavantage.co/academy/#database-model)

数据库是大多数现代 Web 和移动应用程序的重要组成部分。对于我们的股票可视化网站，我们将创建一个简单的（两列）数据库模型来存储股票市场数据。

然而，在我们创建数据库模型之前，让我们打开`settings.py`文件并快速修改脚本中的以下 3 个地方：

1. 在`settings.py` 的顶部附近，添加`import os`

```python
from pathlib import Path
import os #add this line to settings.py
```



2. 在`INSTALLED_APPS`里面，添加`stockVisualizer`应用程序：

```python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'stockVisualizer', #add this line to settings.py
]
```



3. 在`TEMPLATES`里面，引入我们之前在这个项目中创建的`templates`目录：

```python
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')], #modify this line in settings.py
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
```



现在，让我们在`models.py`中定义一个名为`StockData`的 Django 数据库模型。

该模型有两个字段：

❚`symbol`字段，用于存储股票代码字符串

❚`data`字段，用于存储给定代码的历史价格和移动平均值

```python
#models.py


from django.db import models


# Create your models here.
class StockData(models.Model):
    symbol = models.TextField(null=True)
    data = models.TextField(null=True)
```



`models.py`文件更新后，让我们使用以下命令行指令将新创建的数据库模型通知给 Django：

```
(alphaVantage) $ python manage.py makemigrations
(alphaVantage) $ python manage.py migrate
```



此时，您的文件结构应类似于如下所示：

```
alphaVantage/
    alphaVantage/
        __init__.py
        asgi.py
        settings.py
        urls.py
        wsgi.py
    stockVisualizer/
        migrations/
            0001_initial.py #you should see this after running the database migration commands
            __init__.py
        __init__.py
        admin.py
        apps.py
        models.py
        tests.py
        views.py
    templates/
        home.html
    manage.py
    db.sqlite3 #you should see this after running the database migration commands
```



`db.sqlite3`文件表明我们已经在本地 SQLite 数据库中注册了我们的`StockData`模型。顾名思义，SQLite 是一个轻量级的 SQL 数据库，经常用于 Web 开发（尤其是在本地测试环境中）。SQLite 自动包含在 Django/Python 中，因此无需单独安装 :-)



在完成网站之前只剩下两个步骤：

❚ 设置主页文件 ( `home.html`) 以便我们可以可视化某只给定股票的股价和移动平均线

❚ 创建后端服务器逻辑 ( `views.py`) 以便我们将适当的股票数据输入到前端 UI

让我们继续吧！



#### [创建前端用户界面](https://www.alphavantage.co/academy/#frontend-ui)

在我们深入研究代码实现之前，让我们首先概括地总结一下我们主页的预期行为（截图如下）：

❚ 加载后，页面将显示 Apple (AAPL) 近 500 个交易日的调整后的收盘价和简单移动平均线 (SMA) 值。

❚ 当用户在文本框中输入新的股票代码并点击“提交”时，页面上现有的图表将被新股票调整后的收盘价和 SMA 数据所取代。



首次加载主页时：

![股票可视化主页模型](https://github.com/AlphaVantageSupport/stock_visualization_in_python_django/blob/main/homepage_layout.png?raw=true)



当用户输入一个新的股票代码（如 GME）时：

![带有用户输入的股票可视化工具主页模型](https://github.com/AlphaVantageSupport/stock_visualization_in_python_django/blob/main/homepage_gme.png?raw=true)



定义了上述页面布局和行为后，让我们相应地实现主页前端。

打开（空的）`home.html`文件，并将以下内容粘贴到其中：

```html
<!DOCTYPE html>
<html>
<head>
    <!--<link rel="stylesheet" href="style.css">-->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.2.1/dist/chart.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <title>Stock Visualizer</title>
</head>


<body>
<h2>Interative Stock Visualizer</h2>
<br>


<label for="ticker-input">Enter Symbol:</label>
<input type="text" id="ticker-input">
<input type="button" value="submit" id="submit-btn">
<br>


<div id="graph-area" style="height:80%; width:80%;">
<canvas id="myChart"></canvas>
</div>
<br>


<div>
    Friendly reminder: if the graphing function stops working after several successful instances, don't worry! It is likely that you have reached the 5 requests/minute rate limit of the free Alpha Vantage API key. The graph should work again in the next minute or after you obtain a <a href="https://www.alphavantage.co/premium/" target="_blank">premium API key</a> with a higher rate limit.
</div>


<script>


    $(document).ready(function(){
        // Right after the page is loaded, we get the stock data (default to AAPL) from the Django backend (the 'get_stock_data' function) for plotting
        $.ajax({
              type: "POST",
              url: "/get_stock_data/",
              data: {
                 'ticker': 'AAPL',
              },
              success: function (res, status) {
                // AAPL's stock price and SMA data is now in the "res" object
                var tickerDisplay = res['prices']['Meta Data']['2. Symbol'];
                var graphTitle = tickerDisplay + ' (data for the trailing 500 trading days)'


                var priceSeries = res['prices']['Time Series (Daily)'];
                var daily_adjusted_close = [];
                var dates = [];


                price_data_parse = function(){
                    for (let key in priceSeries) {
                        daily_adjusted_close.push(Number(priceSeries[key]['5. adjusted close']));
                        dates.push(String(key));
                    }


                };
                price_data_parse();


                var smaSeries = res['sma']['Technical Analysis: SMA'];
                var sma_data = [];


                sma_data_parse = function(){
                    for (let key in smaSeries) {
                        sma_data.push(Number(smaSeries[key]['SMA']));
                    }


                };
                sma_data_parse();




                // only keep the latest 500 data points (i.e., data for the latest 500 trading days) for the three lists below
                daily_adjusted_close.reverse().slice(500);
                sma_data.reverse().slice(500);
                dates.reverse().slice(500);


                //instruct Chart.js to plot the graph, with "dates" as the x-axis labels and "daily_adjusted_close" and "sma_data" as the y-axis values
                var ctx = document.getElementById('myChart').getContext('2d');
                var myChart = new Chart(ctx, {
                type: 'line',
                    data: {
                        labels: dates.slice(-500),
                        datasets: [
                            {
                                label: 'Daily Adjusted Close',
                                data: daily_adjusted_close.slice(-500),
                                backgroundColor: [
                                    'green',
                                ],
                                borderColor: [
                                    'green',
                                ],
                                borderWidth: 1
                            },
                            {
                                label: 'Simple Moving Average (SMA)',
                                data: sma_data.slice(-500),
                                backgroundColor: [
                                    'blue',
                                ],
                                borderColor: [
                                    'blue',
                                ],
                                borderWidth: 1
                            },
                        ]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: {
                                //beginAtZero: false
                            }
                        },
                        plugins: {
                            legend: {
                            position: 'top',
                            },
                            title: {
                            display: true,
                            text: graphTitle
                            }
                        }
                    }
                });


              }
        });
    });


    $('#submit-btn').click(function() {
        // when the user specifies a new ticker, we call the Django backend (the 'get_stock_data' function) to get the stock data and refresh the graph. 
        // obtain the ticker string from the input textbox
        var tickerText = $('#ticker-input').val();
        $.ajax({
              type: "POST",
              url: "/get_stock_data/",
              data: {
                 'ticker': tickerText,
              },
              success: function (res, status) {
                // stock price and SMA data for the user-specified ticker is now in the "res" object
                var tickerDisplay = res['prices']['Meta Data']['2. Symbol'];
                var graphTitle = tickerDisplay + ' (data for the trailing 500 trading days)'


                var priceSeries = res['prices']['Time Series (Daily)'];
                var daily_adjusted_close = [];
                var dates = [];


                price_data_parse = function(){
                    for (let key in priceSeries) {
                        daily_adjusted_close.push(Number(priceSeries[key]['5. adjusted close']));
                        dates.push(String(key));
                    }


                };
                price_data_parse();


                var smaSeries = res['sma']['Technical Analysis: SMA'];
                var sma_data = [];


                sma_data_parse = function(){
                    for (let key in smaSeries) {
                        sma_data.push(Number(smaSeries[key]['SMA']));
                    }


                };
                sma_data_parse();




                // only keep the latest 500 data points (i.e., data for the latest 500 trading days) for the three lists below
                daily_adjusted_close.reverse().slice(500);
                sma_data.reverse().slice(500);
                dates.reverse().slice(500);


                //instruct Chart.js to plot the graph, with "dates" as the x-axis labels and "daily_adjusted_close" and "sma_data" as the y-axis values
                $('#myChart').remove(); // this is my <canvas> element
                $('#graph-area').append('<canvas id="myChart"><canvas>');
                var ctx = document.getElementById('myChart').getContext('2d');
                var myChart = new Chart(ctx, {
                type: 'line',
                    data: {
                        labels: dates.slice(-500),
                        datasets: [
                            {
                                label: 'Daily Adjusted Close',
                                data: daily_adjusted_close.slice(-500),
                                backgroundColor: [
                                    'green',
                                ],
                                borderColor: [
                                    'green',
                                ],
                                borderWidth: 1
                            },
                            {
                                label: 'Simple Moving Average (SMA)',
                                data: sma_data.slice(-500),
                                backgroundColor: [
                                    'blue',
                                ],
                                borderColor: [
                                    'blue',
                                ],
                                borderWidth: 1
                            },
                        ]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: {
                                //beginAtZero: false
                            }
                        },
                        plugins: {
                            legend: {
                            position: 'top',
                            },
                            title: {
                            display: true,
                            text: graphTitle
                            }
                        }
                    }
                });


              }
        });




    });


</script>


</body>
</html>
```



这是一个很大的代码块！别担心 - 让我们将其分解为以下 4 个功能组：

**1.加载Javascript依赖**

❚`https://cdn.jsdelivr.net/npm/chart.js@3.2.1/dist/chart.min.js`是用于数据可视化的功能强大的[Chart.js 库](https://www.chartjs.org/)

❚`https://code.jquery.com/jquery-3.6.0.min.js`加载[jquery 库](https://jquery.com/)，可以简化常见的前端开发任务



**2.定义页面布局**

❚`<input type="text" id="ticker-input">`是用户输入新股票代码的输入文本框

❚`<input type="button" value="submit" id="submit-btn">`是提交按钮

❚`<canvas id="myChart"></canvas>`是Chart.js为股票数据可视化生成漂亮图形的画布



**3.定义页面加载时的行为**

`$(document).ready(function(){...}`代码块指定首次加载页面时的行为：

❚ 首先，它会向Django后端函数`get_stock_data`发出一个AJAX POST请求，以获取 AAPL 的价格和简单移动平均数据。AJAX 代表异步 JavaScript 和 XML，这是一种流行的 Javascript 设计模式，它使开发人员能够 (1) 更新网页而无需重新加载页面，(2) 在页面加载后向后端服务器请求数据，(3 ) 在页面加载后从后端服务器接收数据，等其他好处。

❚ AAPL 的数据一旦从后端返回到前端（数据存储在`success: function (res, status) {...}`中的`res`中的变量中），就会被几行 Javascript 代码解析成三个列表：`dates`, `daily_adjusted_close`, 和`sma_data`。

❚ 接着，将这三个列表截断为 size=500（即，过去500 个交易日的数据）以供 Chart.js 可视化。具体来说，`dates`中的值用于 X 轴；`daily_adjusted_close`和`sma_data`中的值用于 Y 轴。



**4.定义用户提交新代码时的行为**

`$('#submit-btn').click(function(){...}`该代码块明确了用户输入新股票代码时的页面行为：

❚ 首先，它会向名为 get_stock_data 的 Django 后端函数发出 AJAX POST 请求，以获取用户输入的股票代码的价格和简单移动平均数据。`var tickerText = $('#ticker-input').val();`这行代码负责从输入文本框中提取股票代码字符串。

❚ 一旦代码的数据由后端返回给前端（数据再次存储在`success: function (res, status) {...}`中的`res`变量中），它会被几行 Javascript 代码解析为三个列表：`dates`, `daily_adjusted_close`, 和`sma_data`。

❚ 接着，将这三个列表截断为 size=500（即，过去500 个交易日的数据）以供 Chart.js 可视化。具体来说，`dates`中的值用于 X 轴；`daily_adjusted_close`和`sma_data`中的值用于 Y 轴。



如您所见，现在get_stock_data 后端函数是前端-后端通信循环中唯一缺少的部分。让我们马上实现它！



#### [创建后端服务器逻辑（views.py）](https://www.alphavantage.co/academy/#backend-logic)

现在，让我们将`views.py`更新为以下内容。不要忘记将`my_alphav_api_key`字符串替换为您实际的 Alpha Vantage API 密钥。

```python
# views.py


from django.shortcuts import render
from django.http import HttpResponse
from django.views.decorators.csrf import csrf_exempt
from .models import StockData


import requests
import json




APIKEY = 'my_alphav_api_key' 
#replace 'my_alphav_api_key' with your actual Alpha Vantage API key obtained from https://www.alphavantage.co/support/#api-key




DATABASE_ACCESS = True 
#if False, the app will always query the Alpha Vantage APIs regardless of whether the stock data for a given ticker is already in the local database




#view function for rendering home.html
def home(request):
    return render(request, 'home.html', {})


@csrf_exempt
def get_stock_data(request):
    if request.is_ajax():
        #get ticker from the AJAX POST request
        ticker = request.POST.get('ticker', 'null')
        ticker = ticker.upper()


        if DATABASE_ACCESS == True:
            #checking if the database already has data stored for this ticker before querying the Alpha Vantage API
            if StockData.objects.filter(symbol=ticker).exists(): 
                #We have the data in our database! Get the data from the database directly and send it back to the frontend AJAX call
                entry = StockData.objects.filter(symbol=ticker)[0]
                return HttpResponse(entry.data, content_type='application/json')


        #obtain stock data from Alpha Vantage APIs
        #get adjusted close data
        price_series = requests.get(f'https://www.alphavantage.co/query?function=TIME_SERIES_DAILY_ADJUSTED&symbol={ticker}&apikey={APIKEY}&outputsize=full').json()
        
        #get SMA (simple moving average) data
        sma_series = requests.get(f'https://www.alphavantage.co/query?function=SMA&symbol={ticker}&interval=daily&time_period=10&series_type=close&apikey={APIKEY}').json()


        #package up the data in an output dictionary 
        output_dictionary = {}
        output_dictionary['prices'] = price_series
        output_dictionary['sma'] = sma_series


        #save the dictionary to database
        temp = StockData(symbol=ticker, data=json.dumps(output_dictionary))
        temp.save()


        #return the data back to the frontend AJAX call 
        return HttpResponse(json.dumps(output_dictionary), content_type='application/json')


    else:
        message = "Not Ajax"
        return HttpResponse(message)
```



让我们仔细看看上面的后端服务器端代码。

变量`DATABASE_ACCESS = True`意味着`get_stock_data`函数将在对Alpha Vantage进行API调用之前，先检查本地数据库中是否存在现有数据。如果您设置 DATABASE_ACCESS = False，该脚本将绕过所有本地数据库查询，并在查询新股票代码时直接调用 Alpha Vantage API。我们在本教程的参考资料中，包含了一段标题为[数据新鲜度与速度的权衡](https://www.alphavantage.co/academy/#django-references)的段落，以讨论从本地数据库获取数据与查询外部 API 的细微差别。

函数`def home(request)`是 Django 后端渲染 HTML 文件的标准方式（在我们的示例中为`home.html`）。



函数`def get_stock_data(request)`接受来自 home.html 文件的 AJAX POST 请求，并将股票数据的 JSON 字典返回给 AJAX 循环。详细介绍如下：

❚ `if request.is_ajax()`确保请求确实是来自前端的 AJAX POST 请求。

❚ `ticker = request.POST.get('ticker', 'null')`从 AJAX 请求中获取股票代码字符串。首次加载页面时，股票代码字符串始终为 AAPL，但会根据前端的用户输入更改为其他字符串。

❚ 在`if DATABASE_ACCESS == True`下面的代码块，会检查给定股票代码的数据是否已经存在于我们的本地数据库中。如果是，`get_stock_data`函数将从数据库中获取数据并将其返回给 AJAX 循环。如果没有，脚本将继续执行后续步骤。（如果你熟悉 SQL，代码`StockData.objects.filter(symbol=ticker)`就是 Django 实现`SELECT * FROM StockData WHERE symbol = ticker`的方式。）



`price_series = requests.get(f'https://www.alphavantage.co/query?function=TIME_SERIES_DAILY_ADJUSTED&symbol={ticker}&apikey={APIKEY}&outputsize=full').json()`代码块表示查询Alpha Vantage的Daily Adjusted API，并通过`.json()`方法将数据解析成JSON字典。以下是Daily Adjusted API的JSON 输出示例：

```
{
    "Meta Data": {
        "1. Information": "Daily Time Series with Splits and Dividend Events",
        "2. Symbol": "AAPL",
        "3. Last Refreshed": "2021-05-10",
        "4. Output Size": "Full size",
        "5. Time Zone": "US/Eastern"
    },
    "Time Series (Daily)": {
        "2021-05-10": {
            "1. open": "129.41",
            "2. high": "129.54",
            "3. low": "126.81",
            "4. close": "126.85",
            "5. adjusted close": "126.85",
            "6. volume": "88071229",
            "7. dividend amount": "0.0000",
            "8. split coefficient": "1.0"
        },
        "2021-05-07": {
            "1. open": "130.85",
            "2. high": "131.2582",
            "3. low": "129.475",
            "4. close": "130.21",
            "5. adjusted close": "130.21",
            "6. volume": "78973273",
            "7. dividend amount": "0.2200",
            "8. split coefficient": "1.0"
        },
        "2021-05-06": {
            "1. open": "127.89",
            "2. high": "129.75",
            "3. low": "127.13",
            "4. close": "129.74",
            "5. adjusted close": "129.521163843",
            "6. volume": "78128334",
            "7. dividend amount": "0.0000",
            "8. split coefficient": "1.0"
        },
        ...
    }
}
```

请注意，我们主要对Alpha Vantage的Daily Adjusted API的调整收盘价(`5. adjusted close`)感兴趣，以消除由于股票拆分和股息支付事件引起的任何人为价格波动。通常认为使用拆分/股息调整后的价格而不是原始收盘价 ( `4. close`) ，是用来模拟股票价格变动的[行业最佳实践](http://www.crsp.org/products/documentation/crsp-calculations)

❚ `sma_series = requests.get(f'https://www.alphavantage.co/query?function=SMA&symbol={ticker}&interval=daily&time_period=10&series_type=close&apikey={APIKEY}').json()`查询 Alpha Vantage 的Simple Moving Average (SMA) API，并通过`.json()`方法将数据解析为 JSON 字典。以下是 SMA API 的 JSON 示例输出：

```
{
    "Meta Data": {
        "1: Symbol": "AAPL",
        "2: Indicator": "Simple Moving Average (SMA)",
        "3: Last Refreshed": "2021-05-10",
        "4: Interval": "daily",
        "5: Time Period": 10,
        "6: Series Type": "close",
        "7: Time Zone": "US/Eastern"
    },
    "Technical Analysis: SMA": {
        "2021-05-10": {
            "SMA": "130.6427"
        },
        "2021-05-07": {
            "SMA": "131.4070"
        },
        "2021-05-06": {
            "SMA": "131.7953"
        },
        "2021-05-05": {
            "SMA": "132.0150"
        },
        ...
     }
}
```



`get_stock_data`函数的其余部分（如下所示）（1）将调整后的收盘JSON数据和简单移动平均JSON数据打包到字典`output_dictionary`中，（2）将新获取的股票数据保存到数据库中（以便我们下次可以从数据库中获取数据，而无需再次查询Alpha Vantage Api)， (3) 将数据返回到 AJAX POST 循环（通过`HttpResponse(json.dumps(output_dictionary), content_type='application/json')`）以便在前端绘制图表。

```python
#package up the data as a dictionary 
output_dictionary['prices'] = price_series
output_dictionary['sma'] = sma_series


#save the dictionary to database
temp = StockData(symbol=ticker, data=json.dumps(output_dictionary))
temp.save()


#return the data back to the frontend AJAX call 
return HttpResponse(json.dumps(output_dictionary), content_type='application/json')
```



就是它了！我们已经实现了前端 ( `home.html`) 和后端 ( `views.py`)。这些组件现在可以无缝地相互“对话”，并与本地 SQLite 数据库进行读/写交互。



#### [URL路由](https://www.alphavantage.co/academy/#url-routing)

最后一件事：让我们为刚刚在 views.py 中创建的视图，用最新的 URL 路由更新`urls.py`：

❚`path("", stockVisualizer.views.home)`确保当用户在他们的网络浏览器中访问主页时，调用`views.py`中的`home`函数

❚`path('get_stock_data/', stockVisualizer.views.get_stock_data)`确保在`home.html`向`/get_stock_data/` URL 发送 AJAX POST 请求时，views.py 中的`get_stock_data`函数会被调用。

```python
#urls.py


from django.contrib import admin
from django.urls import path
import stockVisualizer.views


urlpatterns = [
    path('admin/', admin.site.urls),
    path("", stockVisualizer.views.home),
    path('get_stock_data/', stockVisualizer.views.get_stock_data),
]
```



#### [在本地运行网站](https://www.alphavantage.co/academy/#run-locally)

现在我们已准备好在您的本地环境中运行该网站。在命令行窗口中输入以下指令（请确保您仍在`alphaVantage`根目录中）：

```
(alphaVantage) $ python manage.py runserver
```



如果您在 Web 浏览器（例如 Chrome、Firefox 等）中转到[http://localhost:8000/](http://localhost:8000/) ，您现在应该可以看到该网站的完整运行！



👍 277 | 分享项目链接





#### [参考](https://www.alphavantage.co/academy/#django-references)

项目源码：[链接](https://github.com/AlphaVantageSupport/stock_visualization_in_python_django)



**深思#1：更丰富的数据可视化**

当前的 Web 应用程序支持给定股票的调整后收盘价和简单移动平均线 (SMA) 值的可视化。我们将把它留给您的创造力来丰富可视化。例如，将[加密货币价格](https://www.alphavantage.co/documentation/#digital-currency)与股票价格一起绘制怎么样？如何向图表添加更多[技术指标](https://www.alphavantage.co/documentation/#technical-indicators)，或允许用户能够直接在图表上绘制支撑/阻力线？我们期待您的创作！



**深思#2：数据新鲜度与网站速度的权衡**

`views.py`中的`get_stock_data`的函数，我们首先在本地数据库中搜索给定股票代码的现有数据，然后再查询 Alpha Vantage API。通过本地数据库或内存缓存访问数据通常比查询在线 API 更快（并且计算成本更低）。另一方面，查询 Alpha Vantage API 将保证您获得给定股票代码的最新数据，而本地数据库中的数据本质上是静态的，并且会随着时间的推移逐渐过时。权衡（新鲜数据但网站速度较慢 vs. 陈旧数据但网站速度较快）是数据密集型应用程序开发人员面临的常见困境。你能找到摆脱这种困境的方法吗？比如写一个[cron作业](https://en.wikipedia.org/wiki/Cron)每天刷新数据库，这样本地数据就不会过时？总的来说，数据库优化是软件开发过程中最具挑战性但也是最有价值的任务之一。



注册我们的[周日早市时事新闻](https://sundaymorningmarkets.substack.com)，了解全球重要的金融和经济新闻！每周日，它都会带着纯粹的市场见解出现在你的电子邮件收件箱里。

在量化投资、机器学习、软件工程和区块链技术领域寻找职业机会？完成此处的项目以解锁[Alpha Academy 证书](https://www.alphatournament.com/certificate_guide/)，并会被介绍给硅谷Y Combinator 网络中的顶级公司！



如果您有兴趣将此项目翻译成英语以外的其他语言，请[告诉我们](mailto:support@alphavantage.co)，我们非常感谢您的帮助！

Wenn Sie daran interessiert sind, dieses Projekt ins Deutsche zu übersetzen, [lassen Sie es uns bitte wissen](mailto:support@alphavantage.co) und wir bedanken uns sehr für Ihre Hilfe!

Si está interesado en traducir este proyecto al español, [háganoslo saber](mailto:support@alphavantage.co) y realmente apreciamos tu ayuda。

Se você está interessado em traduzir este projeto para o português, [por favor nos avise](mailto:support@alphavantage.co) enós realmente apreciamos sua ajuda!

如果您有兴趣把这篇文章翻译成中文，请[联系我们](mailto:support@alphavantage.co)。我们非常感谢您的支持！

本プロジェクト和訳ニご兴味お持ちの方う、是非、[お问い合わせください](mailto:support@alphavantage.co)！ご连络お待ちしえおり！

이프로젝트를한국어로번역하는데관심이있으시면 [저희에게알려주십시오](mailto:support@alphavantage.co)。도움을 주셔서 정말 감사합니다!



*免责声明：阿尔法学院的所有内容仅用于教育目的，并非投资建议。*